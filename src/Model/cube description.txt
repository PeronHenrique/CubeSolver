/**
 * The cube is laid out as follows.
 *
 * The sides:
 *
 *   U
 * L F R B
 *   D
 *
 * Color wise:
 *
 *          Y Y Y
 *          Y Y Y
 *          Y Y Y
 *
 * B B B    R R R   G G G   O O O
 * B B B    R R R   G G G   O O O
 * B B B    R R R   G G G   O O O
 *
 *          W W W
 *          W W W
 *          W W W
 *
 * Index wise:
 *
 *
 *               0  1  2 
 *               7     3
 *               6  5  4
 *
 *  8  9 10     16 17 18    24 25 26    32 33 34
 * 15    11     23    19    31    27    39    35
 * 14 13 12     22 21 20    30 29 28    38 37 36
 *
 *              40 41 42
 *              47    43
 *              46 45 44
 *
 * Centers:
 *
 *   0
 * 1 2 3 4
 *   5
 */










     public void move(Move move) {
        switch (move) {
            case U: this.u(); break;
            case U2: this.u2(); break;
            case U_: this.u_(); break;
            case L: this.l(); break;
            case L2: this.l2(); break;
            case L_: this.l_(); break;
            case F: this.f(); break;
            case F2: this.f2(); break;
            case F_: this.f_(); break;
            case R: this.r(); break;
            case R2: this.r2(); break;
            case R_: this.r_(); break;
            case B: this.b(); break;
            case B2: this.b2(); break;
            case B_: this.b_(); break;
            case D: this.d(); break;
            case D2: this.d2(); break;
            case D_: this.d_(); break;
            default: case NONE: break;
        }
    }


    int getCornerIndex(Corner corner) {
        byte[] cornerColors = getCornerColors(corner);

        // The colors range from 0 to 5, per RubiksCube.h.
        // Shifting 1 left by 0...5 gives 1, 2, 4, 8, 16, 32.
        // Adding these together gives a unique number for each corner cubie.

        int codex = (1 << cornerColors[0]) + (1 << cornerColors[1]) + (1 << cornerColors[2]);

        switch (codex) {
            default: 
            case 19: return 0;
            case 25: return 1;
            case 13: return 2;
            case 7: return 3;
            case 50: return 4;
            case 56: return 5;
            case 44: return 6;
            case 38: return 7;
        }
    }


    int getCornerOrientation(Corner index) {
        byte[] corner = getCornerColors(index);

        if (corner[0] == centers[0] || corner[0] == centers[5])
            return 0;

        switch (index) {
            default:
            case ULB: case URF: case DLF: case DRB:
                return (corner[1] == centers[0] || corner[1] == centers[5]) ? 1 : 2;

            case URB: case ULF: case DLB: case DRF:
                return (corner[2] == centers[0] || corner[2] == centers[5]) ? 1 : 2;
        }
    }

    int getEdgeIndex(Edge edge) {
        byte[] edgeColors = getEdgeColors(edge);

        // The colors range from 0 to 5, per RubiksCube.h.
        // Shifting 1 left by 0...5 gives 1, 2, 4, 8, 16, 32.
        // Adding these together gives a unique number for each edge cubie.
        int codex = (1 << edgeColors[0]) + (1 << edgeColors[1]);

        switch (codex) {
            default: 
            case 17: return 0;
            case 9: return 1;
            case 5: return 2;
            case 3: return 3; 
            case 18: return 4;
            case 24: return 5;
            case 12: return 6;
            case 6: return 7;
            case 48: return 8;
            case 40: return 9;
            case 36: return 10;
            case 34: return 11;
        }
    }